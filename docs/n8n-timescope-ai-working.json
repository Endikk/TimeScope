{
    "name": "TimeScope AI Assistant - Production Ready",
    "nodes": [
        {
            "parameters": {
                "httpMethod": "POST",
                "path": "chat",
                "responseMode": "responseNode",
                "options": {}
            },
            "id": "webhook-chat",
            "name": "Webhook Chat",
            "type": "n8n-nodes-base.webhook",
            "typeVersion": 2,
            "position": [
                240,
                400
            ]
        },
        {
            "parameters": {
                "jsCode": "// ===== VALIDATION ET EXTRACTION DU CONTEXTE =====\nconst body = $input.first().json.body;\n\n// Validation des champs requis\nif (!body || !body.message || !body.userId || !body.authToken) {\n  return {\n    json: {\n      error: true,\n      errorType: 'VALIDATION_ERROR',\n      technicalMessage: 'Requ√™te invalide : message, userId et authToken sont requis.',\n      userMessage: body?.message || '',\n      context: 'validation'\n    }\n  };\n}\n\n// Nettoyage et validation du message\nconst userMessage = String(body.message).trim();\nif (userMessage.length === 0) {\n  return {\n    json: {\n      error: true,\n      errorType: 'VALIDATION_ERROR',\n      technicalMessage: 'Le message ne peut pas √™tre vide.',\n      userMessage: userMessage,\n      context: 'validation'\n    }\n  };\n}\n\nif (userMessage.length > 500) {\n  return {\n    json: {\n      error: true,\n      errorType: 'VALIDATION_ERROR',\n      technicalMessage: 'Le message est trop long (maximum 500 caract√®res).',\n      userMessage: userMessage,\n      context: 'validation'\n    }\n  };\n}\n\n// Extraction et validation du contexte\nreturn {\n  json: {\n    error: false,\n    userMessage: userMessage,\n    userId: String(body.userId),\n    authToken: String(body.authToken),\n    timestamp: new Date().toISOString()\n  }\n};"
            },
            "id": "validate-input",
            "name": "Validate Input",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                460,
                400
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{ $json.error }}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "check-validation",
            "name": "Check Validation",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                680,
                400
            ]
        },
        {
            "parameters": {
                "method": "GET",
                "url": "http://host.docker.internal:8080/api/projects",
                "authentication": "none",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Authorization",
                            "value": "={{ 'Bearer ' + $('Validate Input').item.json.authToken }}"
                        }
                    ]
                },
                "options": {
                    "timeout": 10000
                }
            },
            "id": "fetch-projects",
            "name": "Fetch Projects",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                900,
                300
            ]
        },
        {
            "parameters": {
                "method": "GET",
                "url": "http://host.docker.internal:8080/api/tasks",
                "authentication": "none",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Authorization",
                            "value": "={{ 'Bearer ' + $('Validate Input').item.json.authToken }}"
                        }
                    ]
                },
                "options": {
                    "timeout": 10000
                }
            },
            "id": "fetch-tasks",
            "name": "Fetch Tasks",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                900,
                500
            ]
        },
        {
            "parameters": {
                "jsCode": "// ===== PR√âPARATION DU CONTEXTE POUR L'IA =====\\n\\n// R√©cup√©ration des donn√©es\\nconst context = $('Validate Input').item.json;\\nconst projectsData = $input.all()[0]?.json || [];\\nconst tasksData = $input.all()[1]?.json || [];\\n\\n// Normalisation des donn√©es\\nconst projects = Array.isArray(projectsData) ? projectsData : [projectsData];\\nconst tasks = Array.isArray(tasksData) ? tasksData : [tasksData];\\n\\n// Filtrer les donn√©es invalides\\nconst validProjects = projects.filter(p => p && p.id && p.name);\\nconst validTasks = tasks.filter(t => t && t.id && t.name && t.projectId);\\n\\n// V√©rification des donn√©es disponibles\\nif (validProjects.length === 0) {\\n  return {\\n    json: {\\n      error: true,\\n      errorType: 'NO_DATA',\\n      technicalMessage: 'Aucun projet disponible.',\\n      userMessage: context.userMessage,\\n      context: 'no_projects'\\n    }\\n  };\\n}\\n\\nif (validTasks.length === 0) {\\n  return {\\n    json: {\\n      error: true,\\n      errorType: 'NO_DATA',\\n      technicalMessage: 'Aucune t√¢che disponible.',\\n      userMessage: context.userMessage,\\n      context: 'no_tasks'\\n    }\\n  };\\n}\\n\\n// Cr√©ation de la liste des projets pour l'IA\\nconst projectsList = validProjects\\n  .map(p => `- ${p.companyName || 'Sans soci√©t√©'} > ${p.name}`)\\n  .join('\\\\n');\\n\\n// Date actuelle\\nconst now = new Date();\\nconst today = now.toISOString().split('T')[0];\\nconst dayOfWeek = now.toLocaleDateString('fr-FR', { weekday: 'long' });\\n\\n// Construction du prompt syst√®me\\nconst systemPrompt = `Tu es l'assistant IA de TimeScope, une application professionnelle de time tracking.\\\\n\\\\n=== TON R√îLE ===\\\\nExtraire avec pr√©cision les informations de saisie de temps depuis le message de l'utilisateur.\\\\n\\\\n=== INFORMATIONS √Ä EXTRAIRE ===\\\\n1. SOCI√âT√â (optionnel) : Nom de la soci√©t√©/entreprise\\\\n2. PROJET (obligatoire) : Nom du projet\\\\n3. T√ÇCHE (obligatoire) : Nom de la t√¢che (DOIT exister dans le projet)\\\\n4. DUR√âE (obligatoire) : Dur√©e en heures d√©cimales\\\\n   - 30min = 0.5h\\\\n   - 1h30 = 1.5h\\\\n   - 2h15 = 2.25h\\\\n   - 3 heures = 3.0h\\\\n5. DATE (optionnel) : Date de la saisie (d√©faut = aujourd'hui)\\\\n\\\\n=== FORMATS SUPPORT√âS ===\\\\n\\\\nFORMAT SLASH (prioritaire) :\\\\n\\\\\"Soci√©t√©/Projet/T√¢che pendant X heures pour le DD/MM/YYYY\\\\\"\\\\nExemples :\\\\n- \\\\\"TimeScope/DevTime/React pendant 3 heures pour le 25/11/2025\\\\\"\\\\n  ‚Üí companyName: \\\\\"TimeScope\\\\\", projectName: \\\\\"DevTime\\\\\", taskName: \\\\\"React\\\\\", durationHours: 3.0, date: \\\\\"2025-11-25\\\\\"\\\\n- \\\\\"GCP/Infrastructure/Documentation pendant 1h30 pour le 28/11/2025\\\\\"\\\\n  ‚Üí companyName: \\\\\"GCP\\\\\", projectName: \\\\\"Infrastructure\\\\\", taskName: \\\\\"Documentation\\\\\", durationHours: 1.5, date: \\\\\"2025-11-28\\\\\"\\\\n\\\\nFORMAT NATUREL :\\\\n- \\\\\"1h30 sur le projet DevTime pour la t√¢che React\\\\\"\\\\n- \\\\\"Soci√©t√© TimeScope projet Backend t√¢che API 2h hier\\\\\"\\\\n- \\\\\"30 minutes de documentation sur Infrastructure\\\\\"\\\\n\\\\nDATES ACCEPT√âES :\\\\n- Format fran√ßais : DD/MM/YYYY (ex: 25/11/2025)\\\\n- Format ISO : YYYY-MM-DD (ex: 2025-11-25)\\\\n- Relatif : \\\\\"aujourd'hui\\\\\", \\\\\"hier\\\\\", \\\\\"demain\\\\\"\\\\n- IMPORTANT : Convertis TOUJOURS les dates fran√ßaises DD/MM/YYYY en format ISO YYYY-MM-DD\\\\n\\\\nDUR√âES ACCEPT√âES :\\\\n- \\\\\"3 heures\\\\\" ‚Üí 3.0\\\\n- \\\\\"1h30\\\\\" ou \\\\\"1h 30\\\\\" ‚Üí 1.5\\\\n- \\\\\"30 minutes\\\\\" ou \\\\\"30min\\\\\" ‚Üí 0.5\\\\n- \\\\\"2h15\\\\\" ‚Üí 2.25\\\\n\\\\n=== R√àGLES STRICTES ===\\\\n‚Ä¢ La t√¢che DOIT exister dans le syst√®me (pas de cr√©ation)\\\\n‚Ä¢ Au moins le PROJET doit √™tre mentionn√©\\\\n‚Ä¢ La dur√©e doit √™tre > 0 et ‚â§ 24 heures\\\\n‚Ä¢ Convertis TOUJOURS la date au format YYYY-MM-DD dans ta r√©ponse\\\\n\\\\n=== PROJETS DISPONIBLES ===\\\\n${projectsList}\\\\n\\\\n=== FORMAT DE R√âPONSE ===\\\\nR√©ponds UNIQUEMENT avec un JSON valide (sans markdown, sans commentaires) :\\\\n\\\\nSi tu comprends tout :\\\\n{\\\\n  \\\\\"understood\\\\\": true,\\\\n  \\\\\"companyName\\\\\": \\\\\"nom soci√©t√©\\\\\" ou null,\\\\n  \\\\\"projectName\\\\\": \\\\\"nom projet\\\\\",\\\\n  \\\\\"taskName\\\\\": \\\\\"nom t√¢che\\\\\",\\\\n  \\\\\"durationHours\\\\\": 1.5,\\\\n  \\\\\"date\\\\\": \\\\\"YYYY-MM-DD\\\\\"\\\\n}\\\\n\\\\nSi des informations manquent :\\\\n{\\\\n  \\\\\"understood\\\\\": false,\\\\n  \\\\\"question\\\\\": \\\\\"Message clair expliquant ce qui manque\\\\\"\\\\n}\\\\n\\\\n=== EXEMPLES COMPLETS ===\\\\nEntr√©e : \\\\\"TimeScope/DevTime/React pendant 3 heures pour le 25/11/2025\\\\\"\\\\nSortie : {\\\\\"understood\\\\\": true, \\\\\"companyName\\\\\": \\\\\"TimeScope\\\\\", \\\\\"projectName\\\\\": \\\\\"DevTime\\\\\", \\\\\"taskName\\\\\": \\\\\"React\\\\\", \\\\\"durationHours\\\\\": 3.0, \\\\\"date\\\\\": \\\\\"2025-11-25\\\\\"}\\\\n\\\\nEntr√©e : \\\\\"GCP/Infrastructure/API 2h hier\\\\\"\\\\nSortie : {\\\\\"understood\\\\\": true, \\\\\"companyName\\\\\": \\\\\"GCP\\\\\", \\\\\"projectName\\\\\": \\\\\"Infrastructure\\\\\", \\\\\"taskName\\\\\": \\\\\"API\\\\\", \\\\\"durationHours\\\\\": 2.0, \\\\\"date\\\\\": \\\\\"calculer hier\\\\\"}\\\\n\\\\nEntr√©e : \\\\\"1h30 sur DevTime pour React\\\\\"\\\\nSortie : {\\\\\"understood\\\\\": true, \\\\\"companyName\\\\\": null, \\\\\"projectName\\\\\": \\\\\"DevTime\\\\\", \\\\\"taskName\\\\\": \\\\\"React\\\\\", \\\\\"durationHours\\\\\": 1.5, \\\\\"date\\\\\": \\\\\"${today}\\\\\"}\\\\n\\\\n=== CONTEXTE ACTUEL ===\\\\nDate : ${today} (${dayOfWeek})\\\\nNombre de projets : ${validProjects.length}\\\\nNombre de t√¢ches : ${validTasks.length}`;\\n\\nconst userPrompt = `Message utilisateur : \\\\\"${context.userMessage}\\\\\"`;\\n\\nreturn {\\n  json: {\\n    error: false,\\n    systemPrompt: systemPrompt,\\n    userPrompt: userPrompt,\\n    authToken: context.authToken,\\n    userId: context.userId,\\n    projects: validProjects,\\n    tasks: validTasks,\\n    timestamp: context.timestamp,\\n    userMessage: context.userMessage\\n  }\\n};"
            },
            "id": "prepare-ai-context",
            "name": "Prepare AI Context",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1120,
                400
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{ $json.error }}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "check-data-availability",
            "name": "Check Data Availability",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                1340,
                400
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "http://timescope-ollama:11434/api/chat",
                "authentication": "none",
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ \n  {\n    \"model\": \"llama3.2\",\n    \"messages\": [\n      {\n        \"role\": \"system\",\n        \"content\": $json.systemPrompt\n      },\n      {\n        \"role\": \"user\",\n        \"content\": $json.userPrompt\n      }\n    ],\n    \"stream\": false,\n    \"format\": \"json\",\n    \"options\": {\n      \"temperature\": 0.1,\n      \"top_p\": 0.9\n    }\n  }\n}}",
                "options": {
                    "timeout": 30000
                }
            },
            "id": "call-ollama",
            "name": "Call Ollama AI",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                1560,
                500
            ]
        },
        {
            "parameters": {
                "jsCode": "// ===== PARSING ET VALIDATION DE LA R√âPONSE IA =====\n\nconst aiResponse = $input.first().json;\nconst context = $('Prepare AI Context').first().json;\n\n// Extraction du contenu de la r√©ponse\nlet messageContent = aiResponse.message?.content || '{}';\n\n// Parsing JSON avec gestion d'erreur robuste\nlet parsed;\ntry {\n  messageContent = messageContent.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  parsed = JSON.parse(messageContent);\n} catch (e) {\n  const jsonMatch = messageContent.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    try {\n      parsed = JSON.parse(jsonMatch[0]);\n    } catch (e2) {\n      return {\n        json: {\n          error: true,\n          errorType: 'AI_PARSE_ERROR',\n          technicalMessage: 'L\\'IA n\\'a pas pu parser la r√©ponse.',\n          userMessage: context.userMessage,\n          context: 'ai_parsing_failed'\n        }\n      };\n    }\n  } else {\n    return {\n      json: {\n        error: true,\n        errorType: 'AI_PARSE_ERROR',\n        technicalMessage: 'L\\'IA n\\'a pas retourn√© de JSON valide.',\n        userMessage: context.userMessage,\n        context: 'ai_no_json'\n      }\n    };\n  }\n}\n\n// V√©rification de la compr√©hension\nif (!parsed.understood) {\n  return {\n    json: {\n      error: true,\n      errorType: 'INCOMPLETE_REQUEST',\n      technicalMessage: parsed.question || 'Informations manquantes.',\n      userMessage: context.userMessage,\n      context: 'incomplete_info'\n    }\n  };\n}\n\n// Validation des champs obligatoires\nif (!parsed.projectName || !parsed.taskName || !parsed.durationHours) {\n  return {\n    json: {\n      error: true,\n      errorType: 'MISSING_FIELDS',\n      technicalMessage: 'Champs manquants : projet, t√¢che ou dur√©e.',\n      userMessage: context.userMessage,\n      context: 'missing_fields'\n    }\n  };\n}\n\n// Validation de la dur√©e\nconst duration = parseFloat(parsed.durationHours);\nif (isNaN(duration) || duration <= 0 || duration > 24) {\n  return {\n    json: {\n      error: true,\n      errorType: 'INVALID_DURATION',\n      technicalMessage: `Dur√©e invalide : ${parsed.durationHours}h`,\n      userMessage: context.userMessage,\n      requestedDuration: parsed.durationHours,\n      context: 'invalid_duration'\n    }\n  };\n}\n\n// Validation et normalisation de la date\nlet targetDate = parsed.date || new Date().toISOString().split('T')[0];\ntry {\n  const dateObj = new Date(targetDate);\n  if (isNaN(dateObj.getTime())) {\n    throw new Error('Date invalide');\n  }\n  targetDate = dateObj.toISOString().split('T')[0];\n} catch (e) {\n  return {\n    json: {\n      error: true,\n      errorType: 'INVALID_DATE',\n      technicalMessage: `Date invalide : ${parsed.date}`,\n      userMessage: context.userMessage,\n      requestedDate: parsed.date,\n      context: 'invalid_date'\n    }\n  };\n}\n\n// Passage √† la suite avec les donn√©es valid√©es\nreturn {\n  json: {\n    error: false,\n    parsedData: {\n      companyName: parsed.companyName || null,\n      projectName: String(parsed.projectName).trim(),\n      taskName: String(parsed.taskName).trim(),\n      durationHours: duration,\n      date: targetDate\n    },\n    context: {\n      authToken: context.authToken,\n      userId: context.userId,\n      projects: context.projects,\n      tasks: context.tasks,\n      userMessage: context.userMessage\n    }\n  }\n};"
            },
            "id": "parse-ai-response",
            "name": "Parse AI Response",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1780,
                500
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{ $json.error }}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "check-parsing",
            "name": "Check Parsing",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                2000,
                500
            ]
        },
        {
            "parameters": {
                "jsCode": "// ===== VALIDATION DE LA DATE (WEEK-END ET JOURS F√âRI√âS) =====\n\nconst data = $input.first().json;\nconst parsed = data.parsedData;\n\nconst dateObj = new Date(parsed.date);\nconst dayOfWeek = dateObj.getDay();\n\n// V√©rification week-end\nif (dayOfWeek === 0 || dayOfWeek === 6) {\n  const dayName = dayOfWeek === 0 ? 'dimanche' : 'samedi';\n  return {\n    json: {\n      error: true,\n      errorType: 'WEEKEND_DATE',\n      technicalMessage: `Date week-end : ${parsed.date} (${dayName})`,\n      userMessage: data.context.userMessage,\n      requestedDate: parsed.date,\n      dayName: dayName,\n      context: 'weekend'\n    }\n  };\n}\n\n// Jours f√©ri√©s fran√ßais 2024-2026\nconst holidays = [\n  '2024-01-01', '2024-04-01', '2024-05-01', '2024-05-08', '2024-05-09', \n  '2024-05-20', '2024-07-14', '2024-08-15', '2024-11-01', '2024-11-11', '2024-12-25',\n  '2025-01-01', '2025-04-21', '2025-05-01', '2025-05-08', '2025-05-29', \n  '2025-06-09', '2025-07-14', '2025-08-15', '2025-11-01', '2025-11-11', '2025-12-25',\n  '2026-01-01', '2026-04-06', '2026-05-01', '2026-05-08', '2026-05-14', \n  '2026-05-25', '2026-07-14', '2026-08-15', '2026-11-01', '2026-11-11', '2026-12-25'\n];\n\nif (holidays.includes(parsed.date)) {\n  return {\n    json: {\n      error: true,\n      errorType: 'HOLIDAY_DATE',\n      technicalMessage: `Jour f√©ri√© : ${parsed.date}`,\n      userMessage: data.context.userMessage,\n      requestedDate: parsed.date,\n      context: 'holiday'\n    }\n  };\n}\n\n// Date valide, continuer\nreturn {\n  json: {\n    error: false,\n    parsedData: parsed,\n    context: data.context\n  }\n};"
            },
            "id": "validate-date",
            "name": "Validate Date",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2220,
                600
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{ $json.error }}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "check-date",
            "name": "Check Date",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                2440,
                600
            ]
        },
        {
            "parameters": {
                "jsCode": "// ===== RECHERCHE ET VALIDATION DU PROJET =====\n\nconst data = $input.first().json;\nconst parsed = data.parsedData;\nconst projects = data.context.projects;\n\nconst projectName = parsed.projectName.toLowerCase();\nconst companyName = parsed.companyName ? parsed.companyName.toLowerCase() : null;\n\n// Fonction de matching flexible\nconst matchScore = (project) => {\n  let score = 0;\n  const pName = project.name.toLowerCase();\n  const pCompany = project.companyName ? project.companyName.toLowerCase() : null;\n  \n  if (pName === projectName) score += 100;\n  else if (pName.includes(projectName) || projectName.includes(pName)) score += 50;\n  \n  if (companyName && pCompany) {\n    if (pCompany === companyName) score += 100;\n    else if (pCompany.includes(companyName) || companyName.includes(pCompany)) score += 50;\n  }\n  \n  return score;\n};\n\nconst scoredProjects = projects\n  .map(p => ({ project: p, score: matchScore(p) }))\n  .filter(sp => sp.score > 0)\n  .sort((a, b) => b.score - a.score);\n\nif (scoredProjects.length === 0) {\n  const availableList = projects.slice(0, 5).map(p => `${p.companyName || 'Sans soci√©t√©'} > ${p.name}`).join(', ');\n  return {\n    json: {\n      error: true,\n      errorType: 'PROJECT_NOT_FOUND',\n      technicalMessage: `Projet non trouv√© : ${parsed.projectName}`,\n      userMessage: data.context.userMessage,\n      requestedProject: parsed.projectName,\n      requestedCompany: parsed.companyName,\n      availableProjects: availableList,\n      context: 'project_not_found'\n    }\n  };\n}\n\nconst maxScore = scoredProjects[0].score;\nconst topMatches = scoredProjects.filter(sp => sp.score === maxScore);\n\nif (topMatches.length > 1) {\n  const matchList = topMatches.map(sp => `${sp.project.companyName || 'Sans soci√©t√©'} > ${sp.project.name}`).join(', ');\n  return {\n    json: {\n      error: true,\n      errorType: 'AMBIGUOUS_PROJECT',\n      technicalMessage: `Plusieurs projets correspondent`,\n      userMessage: data.context.userMessage,\n      requestedProject: parsed.projectName,\n      matches: matchList,\n      context: 'ambiguous_project'\n    }\n  };\n}\n\nconst matchedProject = scoredProjects[0].project;\n\nreturn {\n  json: {\n    error: false,\n    matchedProject: matchedProject,\n    parsedData: parsed,\n    context: data.context\n  }\n};"
            },
            "id": "find-project",
            "name": "Find Project",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2660,
                700
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{ $json.error }}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "check-project",
            "name": "Check Project",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                2880,
                700
            ]
        },
        {
            "parameters": {
                "jsCode": "// ===== RECHERCHE ET VALIDATION DE LA T√ÇCHE =====\n\nconst data = $input.first().json;\nconst parsed = data.parsedData;\nconst matchedProject = data.matchedProject;\nconst allTasks = data.context.tasks;\n\nconst projectTasks = allTasks.filter(t => t.projectId === matchedProject.id);\n\nif (projectTasks.length === 0) {\n  return {\n    json: {\n      error: true,\n      errorType: 'NO_TASKS_IN_PROJECT',\n      technicalMessage: `Aucune t√¢che dans le projet ${matchedProject.name}`,\n      userMessage: data.context.userMessage,\n      projectName: matchedProject.name,\n      context: 'no_tasks'\n    }\n  };\n}\n\nconst taskName = parsed.taskName.toLowerCase();\n\nconst matchTask = (task) => {\n  const tName = task.name.toLowerCase();\n  if (tName === taskName) return 100;\n  if (tName.replace(/\\s+/g, '') === taskName.replace(/\\s+/g, '')) return 90;\n  if (tName.includes(taskName)) return 70;\n  if (taskName.includes(tName)) return 60;\n  if (tName.startsWith(taskName)) return 50;\n  return 0;\n};\n\nconst scoredTasks = projectTasks\n  .map(t => ({ task: t, score: matchTask(t) }))\n  .filter(st => st.score > 0)\n  .sort((a, b) => b.score - a.score);\n\nif (scoredTasks.length === 0) {\n  const availableTasks = projectTasks.slice(0, 10).map(t => t.name).join(', ');\n  return {\n    json: {\n      error: true,\n      errorType: 'TASK_NOT_FOUND',\n      technicalMessage: `T√¢che non trouv√©e : ${parsed.taskName}`,\n      userMessage: data.context.userMessage,\n      requestedTask: parsed.taskName,\n      projectName: matchedProject.name,\n      availableTasks: availableTasks,\n      context: 'task_not_found'\n    }\n  };\n}\n\nconst matchedTask = scoredTasks[0].task;\n\nif (scoredTasks[0].score < 60 && scoredTasks.length > 1) {\n  const suggestions = scoredTasks.slice(0, 3).map(st => st.task.name).join(', ');\n  return {\n    json: {\n      error: true,\n      errorType: 'AMBIGUOUS_TASK',\n      technicalMessage: `Correspondance floue pour la t√¢che`,\n      userMessage: data.context.userMessage,\n      requestedTask: parsed.taskName,\n      suggestions: suggestions,\n      context: 'ambiguous_task'\n    }\n  };\n}\n\nreturn {\n  json: {\n    error: false,\n    matchedProject: matchedProject,\n    matchedTask: matchedTask,\n    parsedData: parsed,\n    context: data.context\n  }\n};"
            },
            "id": "find-task",
            "name": "Find Task",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                3100,
                800
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{ $json.error }}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "check-task",
            "name": "Check Task",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                3320,
                800
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "http://host.docker.internal:8080/api/timeentries",
                "authentication": "none",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Authorization",
                            "value": "={{ 'Bearer ' + $json.context.authToken }}"
                        },
                        {
                            "name": "Content-Type",
                            "value": "application/json"
                        }
                    ]
                },
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ \n  {\n    \"taskId\": $json.matchedTask.id,\n    \"userId\": $json.context.userId,\n    \"date\": $json.parsedData.date,\n    \"duration\": (function() {\n      const hours = Math.floor($json.parsedData.durationHours);\n      const minutes = Math.round(($json.parsedData.durationHours - hours) * 60);\n      return hours.toString().padStart(2, '0') + ':' + minutes.toString().padStart(2, '0') + ':00';\n    })(),\n    \"notes\": \"Cr√©√© par l'assistant IA TimeScope\"\n  }\n}}",
                "options": {
                    "timeout": 10000
                }
            },
            "id": "create-time-entry",
            "name": "Create Time Entry",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                3540,
                900
            ]
        },
        {
            "parameters": {
                "jsCode": "// ===== PR√âPARATION DES DONN√âES POUR R√âPONSE IA SUCC√àS =====\n\nconst data = $('Find Task').item.json;\nconst entryResponse = $input.first().json;\n\nconst successData = {\n  company: data.matchedProject.companyName || 'Sans soci√©t√©',\n  project: data.matchedProject.name,\n  task: data.matchedTask.name,\n  duration: data.parsedData.durationHours,\n  date: data.parsedData.date,\n  entryId: entryResponse.id,\n  userMessage: data.context.userMessage\n};\n\nreturn {\n  json: successData\n};"
            },
            "id": "prepare-success-data",
            "name": "Prepare Success Data",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                3760,
                900
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "http://timescope-ollama:11434/api/chat",
                "authentication": "none",
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ \n  {\n    \"model\": \"llama3.2\",\n    \"messages\": [\n      {\n        \"role\": \"system\",\n        \"content\": \"Tu es l'assistant IA de TimeScope. L'utilisateur vient de saisir du temps avec succ√®s. G√©n√®re une r√©ponse COURTE, NATURELLE et ENCOURAGEANTE confirmant l'enregistrement.\\n\\nR√àGLES :\\n- Maximum 2-3 phrases\\n- Ton amical et professionnel\\n- Utilise des √©mojis avec parcimonie (1-2 max)\\n- Mentionne les d√©tails cl√©s : projet, t√¢che, dur√©e\\n- Varie tes r√©ponses (ne r√©p√®te pas toujours la m√™me formule)\\n- Sois concis\\n\\nExemples :\\n- \\\"‚úÖ Parfait ! J'ai enregistr√© 2h sur le projet DevTime pour la t√¢che React. Bonne continuation !\\\"\\n- \\\"C'est not√© ! 1h30 de documentation ajout√©e au projet Infrastructure. üëç\\\"\\n- \\\"Enregistr√© avec succ√®s : 3h sur Backend/API. Continue comme √ßa !\\\"\"\n      },\n      {\n        \"role\": \"user\",\n        \"content\": \"Demande utilisateur : \\\"\" + $json.userMessage + \"\\\"\\n\\nEnregistrement r√©ussi :\\n- Soci√©t√© : \" + $json.company + \"\\n- Projet : \" + $json.project + \"\\n- T√¢che : \" + $json.task + \"\\n- Dur√©e : \" + $json.duration + \"h\\n- Date : \" + $json.date\n      }\n    ],\n    \"stream\": false,\n    \"options\": {\n      \"temperature\": 0.7\n    }\n  }\n}}",
                "options": {
                    "timeout": 15000
                }
            },
            "id": "generate-success-response",
            "name": "Generate Success Response",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                3980,
                900
            ]
        },
        {
            "parameters": {
                "respondWith": "json",
                "responseBody": "={{ \n  {\n    \"success\": true,\n    \"output\": $json.message.content,\n    \"data\": {\n      \"entryId\": $('Prepare Success Data').item.json.entryId,\n      \"project\": $('Prepare Success Data').item.json.project,\n      \"task\": $('Prepare Success Data').item.json.task,\n      \"duration\": $('Prepare Success Data').item.json.duration,\n      \"date\": $('Prepare Success Data').item.json.date\n    }\n  }\n}}"
            },
            "id": "respond-success",
            "name": "Respond Success",
            "type": "n8n-nodes-base.respondToWebhook",
            "typeVersion": 1.1,
            "position": [
                4200,
                900
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "http://timescope-ollama:11434/api/chat",
                "authentication": "none",
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ \n  {\n    \"model\": \"llama3.2\",\n    \"messages\": [\n      {\n        \"role\": \"system\",\n        \"content\": \"Tu es l'assistant IA de TimeScope. Une erreur s'est produite lors de la saisie de temps. G√©n√®re une r√©ponse COURTE, CLAIRE et UTILE pour aider l'utilisateur.\\n\\nR√àGLES :\\n- Maximum 2-3 phrases\\n- Ton empathique mais professionnel\\n- Explique clairement le probl√®me\\n- Donne une solution concr√®te\\n- Utilise 1 √©moji si appropri√©\\n- Sois concis\\n\\nTypes d'erreurs :\\n- validation : Probl√®me avec la requ√™te\\n- no_projects/no_tasks : Pas de donn√©es disponibles\\n- incomplete_info : Informations manquantes\\n- weekend/holiday : Date non autoris√©e\\n- project_not_found : Projet introuvable\\n- task_not_found : T√¢che introuvable\\n- ambiguous_project/task : Plusieurs correspondances\\n- invalid_duration/date : Valeur invalide\\n\\nExemples :\\n- \\\"‚ùå Je n'ai pas trouv√© le projet \\\"DevTime\\\". Projets disponibles : Backend, Frontend, Infrastructure.\\\"\\n- \\\"‚ö†Ô∏è Impossible de saisir du temps le samedi. Essaie avec un jour de semaine.\\\"\\n- \\\"ü§î Plusieurs projets correspondent. Peux-tu pr√©ciser la soci√©t√© ?\\\"\"\n      },\n      {\n        \"role\": \"user\",\n        \"content\": \"Demande utilisateur : \\\"\" + $json.userMessage + \"\\\"\\n\\nType d'erreur : \" + $json.context + \"\\nMessage technique : \" + $json.technicalMessage + (($json.availableProjects || $json.availableTasks || $json.matches || $json.suggestions) ? \"\\n\\nInformations suppl√©mentaires : \" + ($json.availableProjects || $json.availableTasks || $json.matches || $json.suggestions || '') : '')\n      }\n    ],\n    \"stream\": false,\n    \"options\": {\n      \"temperature\": 0.5\n    }\n  }\n}}",
                "options": {
                    "timeout": 15000
                }
            },
            "id": "generate-error-response",
            "name": "Generate Error Response",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                3980,
                300
            ]
        },
        {
            "parameters": {
                "respondWith": "json",
                "responseBody": "={{ \n  {\n    \"success\": false,\n    \"output\": $json.message.content,\n    \"errorType\": $('Merge Errors').item.json.errorType || 'UNKNOWN_ERROR'\n  }\n}}"
            },
            "id": "respond-error",
            "name": "Respond Error",
            "type": "n8n-nodes-base.respondToWebhook",
            "typeVersion": 1.1,
            "position": [
                4200,
                300
            ]
        },
        {
            "parameters": {},
            "id": "merge-errors",
            "name": "Merge Errors",
            "type": "n8n-nodes-base.merge",
            "typeVersion": 3,
            "position": [
                3760,
                300
            ]
        }
    ],
    "connections": {
        "Webhook Chat": {
            "main": [
                [
                    {
                        "node": "Validate Input",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Validate Input": {
            "main": [
                [
                    {
                        "node": "Check Validation",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Check Validation": {
            "main": [
                [
                    {
                        "node": "Merge Errors",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Fetch Projects",
                        "type": "main",
                        "index": 0
                    },
                    {
                        "node": "Fetch Tasks",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Fetch Projects": {
            "main": [
                [
                    {
                        "node": "Prepare AI Context",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Fetch Tasks": {
            "main": [
                [
                    {
                        "node": "Prepare AI Context",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Prepare AI Context": {
            "main": [
                [
                    {
                        "node": "Check Data Availability",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Check Data Availability": {
            "main": [
                [
                    {
                        "node": "Merge Errors",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Call Ollama AI",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Call Ollama AI": {
            "main": [
                [
                    {
                        "node": "Parse AI Response",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Parse AI Response": {
            "main": [
                [
                    {
                        "node": "Check Parsing",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Check Parsing": {
            "main": [
                [
                    {
                        "node": "Merge Errors",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Validate Date",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Validate Date": {
            "main": [
                [
                    {
                        "node": "Check Date",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Check Date": {
            "main": [
                [
                    {
                        "node": "Merge Errors",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Find Project",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Find Project": {
            "main": [
                [
                    {
                        "node": "Check Project",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Check Project": {
            "main": [
                [
                    {
                        "node": "Merge Errors",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Find Task",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Find Task": {
            "main": [
                [
                    {
                        "node": "Check Task",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Check Task": {
            "main": [
                [
                    {
                        "node": "Merge Errors",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Create Time Entry",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Create Time Entry": {
            "main": [
                [
                    {
                        "node": "Prepare Success Data",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Prepare Success Data": {
            "main": [
                [
                    {
                        "node": "Generate Success Response",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Generate Success Response": {
            "main": [
                [
                    {
                        "node": "Respond Success",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Merge Errors": {
            "main": [
                [
                    {
                        "node": "Generate Error Response",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Generate Error Response": {
            "main": [
                [
                    {
                        "node": "Respond Error",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "pinData": {},
    "settings": {
        "executionOrder": "v1"
    },
    "staticData": null,
    "tags": [
        "TimeScope",
        "AI",
        "Production"
    ],
    "triggerCount": 0,
    "updatedAt": "2025-11-29T22:34:00.000Z",
    "versionId": "4"
}